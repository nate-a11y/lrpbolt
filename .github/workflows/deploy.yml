name: Build & Deploy LRP (beast mode)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: lrp-deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      # Ensure lockfile so npm ci is deterministic
      - name: Ensure package-lock.json
        run: |
          if [ ! -f package-lock.json ]; then
            echo "No package-lock.json found; generating one‚Ä¶"
            npm install --package-lock-only --no-audit --no-fund
          fi

      # Fail fast if any required secret is missing (Vite + FTP)
      - name: Validate required secrets
        run: |
          required=(
            VITE_CALENDAR_API_KEY VITE_CALENDAR_ID
            VITE_FIREBASE_API_KEY VITE_FIREBASE_AUTH_DOMAIN VITE_FIREBASE_PROJECT_ID
            VITE_FIREBASE_STORAGE_BUCKET VITE_FIREBASE_MESSAGING_SENDER_ID VITE_FIREBASE_APP_ID
            VITE_FIREBASE_VAPID_KEY
            VITE_GOOGLE_CLIENT_ID VITE_API_BASE_URL VITE_API_SECRET_KEY VITE_TIME_LOG_CSV
            VITE_DROP_DAILY_URL VITE_SMS_TEST_TO
            HOSTINGER_FTP_HOST HOSTINGER_FTP_USERNAME HOSTINGER_FTP_PASSWORD HOSTINGER_REMOTE_PATH
          )
          for k in "${required[@]}"; do
            v="${!k}"; if [ -z "$v" ]; then echo "::error::Missing secret $k"; exit 1; fi
          done
        env:
          VITE_CALENDAR_API_KEY:               ${{ secrets.VITE_CALENDAR_API_KEY }}
          VITE_CALENDAR_ID:                    ${{ secrets.VITE_CALENDAR_ID }}
          VITE_FIREBASE_API_KEY:               ${{ secrets.VITE_FIREBASE_API_KEY }}
          VITE_FIREBASE_AUTH_DOMAIN:           ${{ secrets.VITE_FIREBASE_AUTH_DOMAIN }}
          VITE_FIREBASE_PROJECT_ID:            ${{ secrets.VITE_FIREBASE_PROJECT_ID }}
          VITE_FIREBASE_STORAGE_BUCKET:        ${{ secrets.VITE_FIREBASE_STORAGE_BUCKET }}
          VITE_FIREBASE_MESSAGING_SENDER_ID:   ${{ secrets.VITE_FIREBASE_MESSAGING_SENDER_ID }}
          VITE_FIREBASE_APP_ID:                ${{ secrets.VITE_FIREBASE_APP_ID }}
          VITE_FIREBASE_VAPID_KEY:             ${{ secrets.VITE_FIREBASE_VAPID_KEY }} 
          VITE_GOOGLE_CLIENT_ID:               ${{ secrets.VITE_GOOGLE_CLIENT_ID }}
          VITE_API_BASE_URL:                   ${{ secrets.VITE_API_BASE_URL }}
          VITE_API_SECRET_KEY:                 ${{ secrets.VITE_API_SECRET_KEY }}
          VITE_TIME_LOG_CSV:                   ${{ secrets.VITE_TIME_LOG_CSV }}
          VITE_DROP_DAILY_URL:                 ${{ secrets.VITE_DROP_DAILY_URL }}
          VITE_SMS_TEST_TO:                    ${{ secrets.VITE_SMS_TEST_TO }}
          HOSTINGER_FTP_HOST:                  ${{ secrets.HOSTINGER_FTP_HOST }}
          HOSTINGER_FTP_USERNAME:              ${{ secrets.HOSTINGER_FTP_USERNAME }}
          HOSTINGER_FTP_PASSWORD:              ${{ secrets.HOSTINGER_FTP_PASSWORD }}
          HOSTINGER_REMOTE_PATH:               ${{ secrets.HOSTINGER_REMOTE_PATH }}

      - name: Create .env from GitHub Secrets
        run: |
          cat > .env << 'EOF'
          VITE_CALENDAR_API_KEY=${{ secrets.VITE_CALENDAR_API_KEY }}
          VITE_CALENDAR_ID=${{ secrets.VITE_CALENDAR_ID }}
          VITE_FIREBASE_API_KEY=${{ secrets.VITE_FIREBASE_API_KEY }}
          VITE_FIREBASE_AUTH_DOMAIN=${{ secrets.VITE_FIREBASE_AUTH_DOMAIN }}
          VITE_FIREBASE_PROJECT_ID=${{ secrets.VITE_FIREBASE_PROJECT_ID }}
          VITE_FIREBASE_STORAGE_BUCKET=${{ secrets.VITE_FIREBASE_STORAGE_BUCKET }}
          VITE_FIREBASE_MESSAGING_SENDER_ID=${{ secrets.VITE_FIREBASE_MESSAGING_SENDER_ID }}
          VITE_FIREBASE_APP_ID=${{ secrets.VITE_FIREBASE_APP_ID }}
          VITE_FIREBASE_VAPID_KEY=${{ secrets.VITE_FIREBASE_VAPID_KEY }}   # ‚Üê add this
          VITE_GOOGLE_CLIENT_ID=${{ secrets.VITE_GOOGLE_CLIENT_ID }}
          VITE_API_BASE_URL=${{ secrets.VITE_API_BASE_URL }}
          VITE_API_SECRET_KEY=${{ secrets.VITE_API_SECRET_KEY }}
          VITE_TIME_LOG_CSV=${{ secrets.VITE_TIME_LOG_CSV }}
          VITE_DROP_DAILY_URL=${{ secrets.VITE_DROP_DAILY_URL }}
          VITE_APP_VERSION=${{ github.sha }}
          EOF

      - name: Create .env.production
        run: |
          echo "VITE_FIREBASE_VAPID_KEY=${{ secrets.VITE_FIREBASE_VAPID_KEY }}" >> .env.production

      - name: Write client env for Vite
        run: |
          echo "VITE_SMS_TEST_TO=${{ secrets.VITE_SMS_TEST_TO }}" >> .env.production


      - name: Set build version
        run: |
          # Install jq if not already available
          if ! command -v jq &> /dev/null; then
          sudo apt-get update && sudo apt-get install -y jq
          fi

          # Read base version from package.json (fallback to 0.0.0)
          BASE_VERSION=$(jq -r '.version // "0.0.0"' package.json)

          # Get today's date
          DATE=$(date +"%Y-%m-%d")
          DATE_TAG=$(date +"%Y%m%d")

          # Use GitHub Actions run number as build count
          COUNT=${GITHUB_RUN_NUMBER}

          # Compose final version
          FINAL_VERSION="${BASE_VERSION}-${DATE_TAG}.${COUNT}"

          # Replace existing VITE_APP_VERSION entry in .env (avoid duplicates)
          sed -i '/^VITE_APP_VERSION=/d' .env 2>/dev/null || true
          echo "VITE_APP_VERSION=$FINAL_VERSION" >> .env

          # Pretty print for Actions log
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üì¶ LRP Driver Portal v$BASE_VERSION"
          echo "   üóì  Build Date: $DATE"
          echo "   üî¢ Build Number: #$COUNT"
          echo "   üè∑  Full Version: $FINAL_VERSION"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""

          # Set as GitHub Actions output
          echo "version=$FINAL_VERSION" >> $GITHUB_OUTPUT

      - name: Install dependencies
        run: npm ci

      # Quality gates ‚Äî keep them beast mode
      - name: Lint
        run: |
          if [ -f package.json ] && npm ls eslint --depth=0 >/dev/null 2>&1; then
          npm run lint --if-present
          else
          echo "‚ö†Ô∏è Skipping lint ‚Äî eslint not installed"
          fi

      - name: Test
        run: |
          if npm ls vitest --depth=0 >/dev/null 2>&1; then
          npm test
          else
          echo "‚ö†Ô∏è Skipping tests ‚Äî vitest not installed"
          fi

      - name: Build (Vite)
        run: npm run build

      # Make sure the SW actually exists in the build
      - name: Verify SW files exist
        run: |
          test -f dist/firebase-messaging-sw.js || { echo "::error::dist/firebase-messaging-sw.js missing"; exit 1; }
          test -f dist/manifest.webmanifest || true

      # Write Hostinger .htaccess so SW/manifest bypass SPA rewrite
      - name: Write Hostinger .htaccess
        run: |
          cat > dist/.htaccess <<'HTACCESS'
          # ---------- MIME hints ----------
          AddType application/javascript .js .mjs
          AddType application/json .json .webmanifest
          AddType text/css .css
          AddType image/png .png
          AddType image/x-icon .ico
          AddType image/svg+xml .svg
          AddType image/webp .webp

          # ---------- React SPA + PWA routing ----------
          RewriteEngine On
          RewriteBase /

          # 1) Serve existing files/directories as-is
          RewriteCond %{REQUEST_FILENAME} -f [OR]
          RewriteCond %{REQUEST_FILENAME} -d
          RewriteRule ^ - [L]

          # 2) Exempt PWA critical files from SPA fallback
          RewriteRule ^(firebase-messaging-sw\.js|sw\.js|service-worker\.js|manifest\.webmanifest|robots\.txt|sitemap\.xml)$ - [L]
          RewriteRule ^icons/ - [L]
          RewriteRule ^assets/ - [L]

          # 3) Everything else -> index.html
          RewriteRule . /index.html [L]
          HTACCESS


      - name: Verify build output
        run: |
          if [ ! -d "dist/assets" ]; then
            echo "‚ùå dist/assets missing"; exit 1; fi
          if ! ls dist/assets/main-*.js 1> /dev/null 2>&1; then
            echo "‚ùå main-*.js not found"; exit 1; fi
          echo "‚úÖ Build artifacts verified"

      - name: Validate precache/service worker
        run: |
          SW="dist/sw.js"
          if [ ! -f "$SW" ]; then echo "‚ùå sw.js missing"; exit 1; fi
          echo "‚úÖ Service worker present"

      # Deploy static site to Hostinger
      - name: Deploy to Hostinger via FTP
        uses: SamKirkland/FTP-Deploy-Action@v4.3.5
        with:
          server: "145.223.77.125"
          username: "u400814892.lakeridepros.xyz"
          password: "m;0C&RhL=AL10b!q"
          protocol: ftp
          local-dir: ./dist/
          server-dir: /public_html/
          log-level: minimal
          exclude: |
            **/.git*
            **/.github*
            **/node_modules/*
            **/src/*
            
  functions:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Validate required secrets
        shell: bash
        run: |
          set -euo pipefail
          missing=0
          if [ -z "${{ secrets.GOOGLE_APPLICATION_CREDENTIALS_JSON }}" ]; then
            echo "::error::Missing GOOGLE_APPLICATION_CREDENTIALS_JSON"
            missing=1
          fi
          if [ -z "${{ secrets.FIREBASE_PROJECT_ID }}" ]; then
            echo "::error::Missing FIREBASE_PROJECT_ID"
            missing=1
          fi
          if [ -z "${{ secrets.MANUAL_DROP_TOKEN }}" ]; then
            echo "::warning::MANUAL_DROP_TOKEN not set (only needed if your functions expect it)"
          fi
          if [ "$missing" -ne 0 ]; then
            exit 1
          fi

      - name: Write service account key
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$HOME/.gcloud"
          # Write JSON exactly as-is (no interpolation)
          cat > "$HOME/.gcloud/key.json" <<'JSON'
          ${{ secrets.GOOGLE_APPLICATION_CREDENTIALS_JSON }}
          JSON
          echo "GOOGLE_APPLICATION_CREDENTIALS=$HOME/.gcloud/key.json" >> "$GITHUB_ENV"

      - name: Export MANUAL_DROP_TOKEN (optional)
        shell: bash
        run: |
          if [ -n "${{ secrets.MANUAL_DROP_TOKEN }}" ]; then
            echo "MANUAL_DROP_TOKEN=${{ secrets.MANUAL_DROP_TOKEN }}" >> "$GITHUB_ENV"
            echo "Set MANUAL_DROP_TOKEN in env."
          else
            echo "MANUAL_DROP_TOKEN not set; continuing."
          fi
      - name: Install Firebase CLI
        run: npm i -g firebase-tools@14

      - name: Install Functions deps
        working-directory: functions
        run: npm ci

      - name: Set Twilio secrets in Firebase
        env:
          TWILIO_ACCOUNT_SID: ${{ secrets.TWILIO_ACCOUNT_SID }}
          TWILIO_AUTH_TOKEN:  ${{ secrets.TWILIO_AUTH_TOKEN }}
          TWILIO_FROM:        ${{ secrets.TWILIO_FROM }}
        run: |
          firebase functions:secrets:set TWILIO_ACCOUNT_SID <<< "$TWILIO_ACCOUNT_SID"
          firebase functions:secrets:set TWILIO_AUTH_TOKEN  <<< "$TWILIO_AUTH_TOKEN"
          firebase functions:secrets:set TWILIO_FROM        <<< "$TWILIO_FROM"

      - name: Deploy Firestore Rules
        run: firebase deploy --only firestore:rules --project "$FIREBASE_PROJECT_ID" --non-interactive
        env:
          FIREBASE_PROJECT_ID: ${{ secrets.FIREBASE_PROJECT_ID }}
          GOOGLE_APPLICATION_CREDENTIALS: ${{ env.GOOGLE_APPLICATION_CREDENTIALS }}

      - name: Deploy Functions
        run: firebase deploy --only functions:smsOnCreate --project "$FIREBASE_PROJECT_ID" --non-interactive
        env:
          FIREBASE_PROJECT_ID: ${{ secrets.FIREBASE_PROJECT_ID }}
          GOOGLE_APPLICATION_CREDENTIALS: ${{ env.GOOGLE_APPLICATION_CREDENTIALS }}
