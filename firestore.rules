rules_version = '2';
// LRP: helper names normalized to avoid reserved/ambiguous identifiers.
// - lower     → toLowerCaseSafe
// - startsWith→ strStartsWithSafe
// - map       → mapVar
// - k         → keyVar
// Unused helpers are removed to keep compiler warnings clean.
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================================
    // WIDE-OPEN OVERRIDE (Public read/write; no auth required)
    // ============================================================
    match /{document=**} {
      allow read, write: if true;
    }

    // ============================================================
    // Schema helpers & collection rules (kept for future lockdown)
    // NOTE: These are effectively bypassed by the wide-open rule above.
    //       Keep them here so you can re-enable fine-grained control later.
    // ============================================================

    // ---------- Auth & helpers ----------
    function toLowerCaseSafe(value) {
      return value.toLowerCase();
    }

    function strStartsWithSafe(haystack, needle) {
      return haystack.size() >= needle.size() && haystack[0:needle.size()] == needle;
    }

    function authed() { return request.auth != null; }

    function email() {
      return authed() && request.auth.token.email is string
        ? toLowerCaseSafe(request.auth.token.email)
        : "";
    }

    function role() {
      return authed() && exists(/databases/$(database)/documents/userAccess/$(email()))
        ? get(/databases/$(database)/documents/userAccess/$(email())).data.access
        : "";
    }

    function userRole(uid) {
      return get(/databases/$(database)/documents/users/$(uid)).data.role;
    }

    function isAdmin()  { return authed() && toLowerCaseSafe(role()) == "admin"; }
    /* removed unused helper: isDriver */

    /* removed unused helper: isOwner */

    // small validators
    function isStrOrNull(v) { return (v is string) || (v == null); }
    function isTsOrNull(v)  { return (v is timestamp) || (v == null); }
    function isNumOrNull(v) { return (v is number) || (v == null); }

    // ---------- Shared helpers for ride docs ----------
    function rideAllowedKeysBase() {
      return [
        // core
        'tripId','pickupTime','rideDuration','rideType','vehicle','rideNotes',
        // claim (new + legacy tolerated)
        'claimedBy','claimedAt','ClaimedBy','ClaimedAt',
        // status & system
        'status','importedFromQueueAt',
        // audit
        'createdAt','createdBy','updatedAt','lastModifiedBy'
      ];
    }

    function rideIsValid(k, v) {
      return
        (k=='tripId'              && isStrOrNull(v)) ||
        (k=='pickupTime'          && v is timestamp) ||
        (k=='rideDuration'        && isNumOrNull(v)) ||
        (k=='rideType'            && isStrOrNull(v)) ||
        (k=='vehicle'             && isStrOrNull(v)) ||
        (k=='rideNotes'           && isStrOrNull(v)) ||
        (k=='claimedBy'           && isStrOrNull(v)) ||
        (k=='ClaimedBy'           && isStrOrNull(v)) ||
        (k=='claimedAt'           && isTsOrNull(v))  ||
        (k=='ClaimedAt'           && isTsOrNull(v))  ||
        (k=='status'              && isStrOrNull(v)) ||
        (k=='importedFromQueueAt' && isTsOrNull(v))  ||
        (k=='createdAt'           && v is timestamp) ||
        (k=='createdBy'           && isStrOrNull(v)) ||
        (k=='updatedAt'           && isTsOrNull(v))  ||
        (k=='lastModifiedBy'      && isStrOrNull(v));
    }

    // tolerate legacy "ClaimedBy"/"ClaimedAt"
    /* removed unused helper: claimedByLower */
    function claimedAtVal(d) {
      return (d.claimedAt != null ? d.claimedAt :
             (d.ClaimedAt != null ? d.ClaimedAt : null));
    }

    // ---------- userAccess ----------
    match /userAccess/{userId} {
      allow read: if authed() && (toLowerCaseSafe(userId) == email() || isAdmin());
      allow create, update, delete: if authed() && isAdmin();
    }

    // userAccessByUid – same idea
    match /userAccessByUid/{uid} {
      allow read: if authed() && (uid == request.auth.uid || isAdmin());
      allow create, update, delete: if authed() && isAdmin();
    }

    match /fcmTokens/{tokenId} {
      function emailPrefix() { return request.auth != null ? request.auth.token.email : ""; }
      // tokenId format: "<email>__<tokenPrefix>"
      function ownsDoc() { return strStartsWithSafe(tokenId, emailPrefix() + "__"); }

      allow create, update, delete: if request.auth != null
        && ownsDoc()
        && request.resource.data.email == emailPrefix()
        && request.resource.data.token is string
        && request.resource.data.updatedAt is timestamp;

      // Users can read their own doc; admins can read all (if you have isAdmin()).
      allow read: if (request.auth != null && ownsDoc())
                  || (request.auth != null && isAdmin());
    }

    // ---------- AdminMeta ----------
    match /AdminMeta/{docId} {
      allow read: if authed();                 // widget reads lastDropDaily etc
      allow create, update, delete: if false;  // writes via Admin SDK only
    }

    // ---------- timeLogs ----------
    match /timeLogs/{id} {
      function allowedKeys() {
        return ['driverEmail','driver','rideId','startTime','endTime','duration','loggedAt','note'];
      }
      function isValid(k, v) {
        return
          (k=='driverEmail' && v is string) ||
          (k=='driver'      && v is string) ||
          (k=='rideId'      && v is string) ||
          (k=='startTime'   && v is timestamp) ||
          (k=='endTime'     && isTsOrNull(v)) ||
          (k=='duration'    && v is number) ||
          (k=='loggedAt'    && v is timestamp) ||
          (k=='note'        && isStrOrNull(v));
      }

      allow read: if authed();

      // Create: minimal "start" fields only
      allow create: if authed()
        && request.resource.data.keys().hasOnly(allowedKeys())
        && request.resource.data.driverEmail is string
        && request.resource.data.driver is string
        && request.resource.data.rideId is string
        && request.resource.data.startTime is timestamp
        && request.resource.data.loggedAt is timestamp
        && !('endTime' in request.resource.data)
        && !('duration' in request.resource.data);

      // Partial-safe update
      allow update: if authed()
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(allowedKeys())
        && request.resource.data.diff(resource.data).changedKeys()
             .map(k, isValid(k, request.resource.data[k]))
             .hasOnly([true]);

      allow delete: if authed();
    }

    // ---------- shootoutStats ----------
    match /shootoutStats/{id} {
      function allowedKeys() {
        return ['driverEmail','vehicle','startTime','endTime','trips','passengers','createdAt'];
      }
      function isValid(k, v) {
        return
          (k=='driverEmail' && v is string) ||
          (k=='vehicle'     && v is string) ||
          (k=='startTime'   && v is timestamp) ||
          (k=='endTime'     && isTsOrNull(v)) ||
          (k=='trips'       && v is number) ||
          (k=='passengers'  && v is number) ||
          (k=='createdAt'   && v is timestamp);
      }

      allow read: if authed() && userRole(request.auth.uid) in ['admin','driver','shootout'];

      // Create: minimal "start" snapshot
      allow create: if authed() && userRole(request.auth.uid) in ['admin','driver','shootout']
        && request.resource.data.keys().hasOnly(allowedKeys())
        && request.resource.data.driverEmail is string
        && request.resource.data.vehicle is string
        && request.resource.data.startTime is timestamp
        && request.resource.data.createdAt is timestamp
        && (!('trips' in request.resource.data) || request.resource.data.trips is number)
        && (!('passengers' in request.resource.data) || request.resource.data.passengers is number)
        && (!('endTime' in request.resource.data) || request.resource.data.endTime is timestamp);

      // Partial-safe update
      allow update: if authed() && userRole(request.auth.uid) in ['admin','driver','shootout']
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(allowedKeys())
        && request.resource.data.diff(resource.data).changedKeys()
             .map(k, isValid(k, request.resource.data[k]))
             .hasOnly([true]);

      allow delete: if authed() && userRole(request.auth.uid) in ['admin','driver','shootout'];
    }

    // ---------- adminLogs ----------
    match /adminLogs/{id} {
      allow read, create, update, delete: if authed() && isAdmin();
    }

    // ---------- rideQueue ----------
    match /rideQueue/{rideId} {
      allow read: if authed();

      allow create: if authed()
        && request.resource.data.keys().hasOnly(rideAllowedKeysBase())
        && request.resource.data.pickupTime is timestamp
        && request.resource.data.tripId is string
        && request.resource.data.createdAt is timestamp;

      // Partial-safe update
      allow update: if authed()
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(rideAllowedKeysBase())
        && request.resource.data.diff(resource.data).changedKeys()
             .map(k, rideIsValid(k, request.resource.data[k]))
             .hasOnly([true]);

      allow delete: if authed();
    }

    // ---------- liveRides ----------
    match /liveRides/{rideId} {
      allow read: if authed();

      allow create: if authed()
        && request.resource.data.keys().hasOnly(rideAllowedKeysBase())
        && request.resource.data.pickupTime is timestamp
        && request.resource.data.tripId is string
        && request.resource.data.createdAt is timestamp;

      allow update: if authed()
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(rideAllowedKeysBase())
        && request.resource.data.diff(resource.data).changedKeys()
             .map(k, rideIsValid(k, request.resource.data[k]))
             .hasOnly([true]);

      allow delete: if authed();
    }

    // ---------- claimedRides ----------
    match /claimedRides/{rideId} {
      allow read: if authed();

      // require claimed on create (new or legacy)
      allow create: if authed()
        && request.resource.data.keys().hasOnly(rideAllowedKeysBase())
        && request.resource.data.pickupTime is timestamp
        && request.resource.data.tripId is string
        && request.resource.data.createdAt is timestamp
        && (
             (request.resource.data.claimedBy is string && request.resource.data.claimedAt is timestamp) ||
             (request.resource.data.ClaimedBy is string && request.resource.data.ClaimedAt is timestamp)
           );

      allow update: if authed()
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(rideAllowedKeysBase())
        && request.resource.data.diff(resource.data).changedKeys()
             .map(k, rideIsValid(k, request.resource.data[k]))
             .hasOnly([true]);

      allow delete: if authed();
    }

    // ---------- tickets ----------
    match /tickets/{ticketId} {
      function allowedKeys() {
        return [
          'pickupTime','passengercount','ticketId','passenger','pickup','dropoff','notes',
          'scannedOutbound','scannedReturn','createdAt',
          'scannedOutboundAt','scannedOutboundBy','scannedReturnAt','scannedReturnBy'
        ];
      }
      function isValid(k, v) {
        return
          (k=='pickupTime'        && v is timestamp) ||
          (k=='passengercount'    && v is number) ||
          (k=='ticketId'          && isStrOrNull(v)) ||
          (k=='passenger'         && isStrOrNull(v)) ||
          (k=='pickup'            && isStrOrNull(v)) ||
          (k=='dropoff'           && isStrOrNull(v)) ||
          (k=='notes'             && isStrOrNull(v)) ||
          (k=='scannedOutbound'   && v is bool) ||
          (k=='scannedReturn'     && v is bool) ||
          (k=='createdAt'         && v is timestamp) ||
          (k=='scannedOutboundAt' && isTsOrNull(v)) ||
          (k=='scannedOutboundBy' && isStrOrNull(v)) ||
          (k=='scannedReturnAt'   && isTsOrNull(v)) ||
          (k=='scannedReturnBy'   && isStrOrNull(v));
      }

      allow read: if authed();

      // Full doc create (strict)
      allow create: if authed()
        && request.resource.data.keys().hasOnly(allowedKeys())
        && request.resource.data.pickupTime is timestamp
        && request.resource.data.passengercount is number
        && request.resource.data.scannedOutbound is bool
        && request.resource.data.scannedReturn is bool
        && request.resource.data.createdAt is timestamp;

      // Partial-safe update
      allow update: if authed()
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(allowedKeys())
        && request.resource.data.diff(resource.data).changedKeys()
             .map(k, isValid(k, request.resource.data[k]))
             .hasOnly([true]);

      allow delete: if authed();
    }

    // ---------- claim logs ----------
    match /claimLog/{id} {
      allow read: if authed();
      allow create, update: if authed()
        && request.resource.data.driver is string
        && request.resource.data.tripId is string
        && request.resource.data.timestamp is timestamp;
      allow delete: if authed();
    }

    match /claimFailures/{id} {
      allow read: if authed();
      allow create, update: if authed()
        && request.resource.data.tripId is string
        && request.resource.data.driverName is string
        && request.resource.data.attemptedAt is timestamp
        && request.resource.data.reason is string;
      allow delete: if authed();
    }

    match /outboundMessages/{id} {
      allow create: if request.auth != null
        && request.resource.data.channel == "sms"
        && request.resource.data.to is string
        && request.resource.data.body is string;
      allow read: if false;
      allow update, delete: if false;
    }

    // ---------- default deny (kept for reference; overridden by wide-open) ----------
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
