rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // KEEP SCHEMA VALIDATION HELPERS
    function authed() { return request.auth != null; }

    function email() {
      return authed() && request.auth.token.email is string
        ? lower(request.auth.token.email)
        : "";
    }

    function role() {
      return authed() && exists(/databases/$(database)/documents/userAccess/$(email()))
        ? get(/databases/$(database)/documents/userAccess/$(email())).data.access
        : "";
    }

    function isAdmin()  { return authed() && lower(role()) == "admin"; }
    function isDriver() { return authed() && lower(role()) == "driver"; }

    function isOwner(data) {
      return authed()
        && data.driverEmail is string
        && lower(data.driverEmail) == email();
    }

    function me() { return email(); }

    // small validators
    function isStrOrNull(v) { return (v is string) || (v == null); }
    function isTsOrNull(v)  { return (v is timestamp) || (v == null); }
    function isNumOrNull(v) { return (v is number) || (v == null); }

    function hasOnly(keys, allowed) {
      // returns true if all keys are within the allowed set
      return keys.hasOnly(allowed);
    }

    function validPartial(newData, validators) {
      return newData.keys().hasOnly(validators.keys()) &&
        newData.keys().map(k => validators[k](newData[k])).hasOnly([true]);
    }

    // tolerate legacy "ClaimedBy"/"ClaimedAt" briefly while code normalizes
    function claimedByLower(d) {
      return lower((d.claimedBy != null ? d.claimedBy :
            (d.ClaimedBy != null ? d.ClaimedBy : "")));
    }
    function claimedAtVal(d) {
      return (d.claimedAt != null ? d.claimedAt :
             (d.ClaimedAt != null ? d.ClaimedAt : null));
    }

    // ---------- userAccess ----------
    // Admins manage; any authed user can read their own
    match /userAccess/{userId} {
      allow read: if authed() && (lower(userId) == email() || isAdmin());
      allow create, update, delete: if authed() && isAdmin();
    }

    // userAccessByUid â€“ same idea
    match /userAccessByUid/{uid} {
      allow read: if authed() && (uid == request.auth.uid || isAdmin());
      allow create, update, delete: if authed() && isAdmin();
    }

    // ---------- AdminMeta ----------
    match /AdminMeta/{docId} {
      allow read: if authed();                 // widget reads lastDropDaily
      allow create, update, delete: if false;  // writes occur via Admin SDK in functions
    }

// ---------- timeLogs ----------
match /timeLogs/{id} {
  function allowedKeys() {
    return [
      'driverEmail','driver','rideId','startTime','endTime','duration','loggedAt'
    ];
  }

  function validators() {
    return {
      driverEmail: (v) => v is string,
      driver:      (v) => v is string,
      rideId:      (v) => v is string,
      startTime:   (v) => v is timestamp,
      endTime:     (v) => isTsOrNull(v),
      duration:    (v) => v is number,
      loggedAt:    (v) => v is timestamp,
    };
  }

  allow read: if authed();

  // Create: minimal "start" fields only
  allow create: if authed()
    && hasOnly(request.resource.data.keys(), allowedKeys())
    && validPartial(request.resource.data, validators())
    && request.resource.data.driverEmail is string
    && request.resource.data.driver is string
    && request.resource.data.rideId is string
    && request.resource.data.startTime is timestamp
    && request.resource.data.loggedAt is timestamp
    // explicitly allow end fields to be absent at create
    && !("endTime" in request.resource.data)
    && !("duration" in request.resource.data);

  // Partial update
  allow update: if authed()
    && hasOnly(request.resource.data.diff(resource.data).changedKeys(), allowedKeys())
    && validPartial(
      request.resource.data.diff(resource.data).affectedKeys()
        .reduce((m, k) => m.put(k, request.resource.data[k]), {}),
      validators()
    );

  allow delete: if authed();
}

// ---------- shootoutStats ----------
match /shootoutStats/{id} {
  function allowedKeys() {
    return [
      'driverEmail','vehicle','startTime','endTime','trips','passengers','createdAt'
    ];
  }

  function validators() {
    return {
      driverEmail: (v) => v is string,
      vehicle:     (v) => v is string,
      startTime:   (v) => v is timestamp,
      endTime:     (v) => isTsOrNull(v),
      trips:       (v) => isNumOrNull(v),
      passengers:  (v) => isNumOrNull(v),
      createdAt:   (v) => v is timestamp,
    };
  }

  allow read: if authed();

  // Create: minimal "start" snapshot
  allow create: if authed()
    && hasOnly(request.resource.data.keys(), allowedKeys())
    && validPartial(request.resource.data, validators())
    && request.resource.data.driverEmail is string
    && request.resource.data.vehicle is string
    && request.resource.data.startTime is timestamp
    && request.resource.data.createdAt is timestamp;

  // Partial update
  allow update: if authed()
    && hasOnly(request.resource.data.diff(resource.data).changedKeys(), allowedKeys())
    && validPartial(
      request.resource.data.diff(resource.data).affectedKeys()
        .reduce((m, k) => m.put(k, request.resource.data[k]), {}),
      validators()
    );

  allow delete: if authed();
}
    // ---------- adminLogs ----------
    // Admins only (keep locked)
    match /adminLogs/{id} {
      allow read, create, update, delete: if authed() && isAdmin();
    }

    // ---------- rideQueue ----------
    // Keep schema; open to any authenticated user
    match /rideQueue/{rideId} {
      function allowedKeys() {
        return [
          'pickupTime','rideDuration','rideType','vehicle','rideNotes',
          'claimedBy','ClaimedBy','claimedAt','ClaimedAt'
        ];
      }

      function validators() {
        return {
          pickupTime: (v) => v is timestamp,
          rideDuration: (v) => isNumOrNull(v),
          rideType: (v) => isStrOrNull(v),
          vehicle: (v) => isStrOrNull(v),
          rideNotes: (v) => isStrOrNull(v),
          claimedBy: (v) => isStrOrNull(v),
          ClaimedBy: (v) => isStrOrNull(v),
          claimedAt: (v) => isTsOrNull(v),
          ClaimedAt: (v) => isTsOrNull(v),
        };
      }

      allow read: if authed();

      allow create: if authed()
        && hasOnly(request.resource.data.keys(), allowedKeys())
        && validPartial(request.resource.data, validators())
        && request.resource.data.pickupTime is timestamp;

      // Partial update
      allow update: if authed()
        && hasOnly(request.resource.data.diff(resource.data).changedKeys(), allowedKeys())
        && validPartial(
          request.resource.data.diff(resource.data).affectedKeys()
            .reduce((m, k) => m.put(k, request.resource.data[k]), {}),
          validators()
        );

      allow delete: if authed();
    }

    // ---------- claimedRides ----------
    // Keep schema; open to any authenticated user
    match /claimedRides/{rideId} {
      function allowedKeys() {
        return [
          'pickupTime','rideDuration','rideType','vehicle','rideNotes',
          'claimedBy','ClaimedBy','claimedAt','ClaimedAt'
        ];
      }

      function validators() {
        return {
          pickupTime: (v) => v is timestamp,
          rideDuration: (v) => isNumOrNull(v),
          rideType: (v) => isStrOrNull(v),
          vehicle: (v) => isStrOrNull(v),
          rideNotes: (v) => isStrOrNull(v),
          claimedBy: (v) => isStrOrNull(v),
          ClaimedBy: (v) => isStrOrNull(v),
          claimedAt: (v) => isTsOrNull(v),
          ClaimedAt: (v) => isTsOrNull(v),
        };
      }

      allow read: if authed();

      allow create: if authed()
        && hasOnly(request.resource.data.keys(), allowedKeys())
        && validPartial(request.resource.data, validators())
        && request.resource.data.pickupTime is timestamp
        && ((request.resource.data.claimedBy is string) || (request.resource.data.ClaimedBy is string))
        && ((request.resource.data.claimedAt is timestamp) || (request.resource.data.ClaimedAt is timestamp));

      // Partial update
      allow update: if authed()
        && hasOnly(request.resource.data.diff(resource.data).changedKeys(), allowedKeys())
        && validPartial(
          request.resource.data.diff(resource.data).affectedKeys()
            .reduce((m, k) => m.put(k, request.resource.data[k]), {}),
          validators()
        );

      allow delete: if authed();
    }

    // ---------- liveRides ----------
    // Keep schema; open to any authenticated user
    match /liveRides/{rideId} {
      function allowedKeys() {
        return [
          'pickupTime','rideDuration','rideType','vehicle','rideNotes',
          'claimedBy','ClaimedBy','claimedAt','ClaimedAt'
        ];
      }

      function validators() {
        return {
          pickupTime: (v) => v is timestamp,
          rideDuration: (v) => isNumOrNull(v),
          rideType: (v) => isStrOrNull(v),
          vehicle: (v) => isStrOrNull(v),
          rideNotes: (v) => isStrOrNull(v),
          claimedBy: (v) => isStrOrNull(v),
          ClaimedBy: (v) => isStrOrNull(v),
          claimedAt: (v) => isTsOrNull(v),
          ClaimedAt: (v) => isTsOrNull(v),
        };
      }

      allow read: if authed();

      allow create: if authed()
        && hasOnly(request.resource.data.keys(), allowedKeys())
        && validPartial(request.resource.data, validators())
        && request.resource.data.pickupTime is timestamp;

      // Partial update
      allow update: if authed()
        && hasOnly(request.resource.data.diff(resource.data).changedKeys(), allowedKeys())
        && validPartial(
          request.resource.data.diff(resource.data).affectedKeys()
            .reduce((m, k) => m.put(k, request.resource.data[k]), {}),
          validators()
        );

      allow delete: if authed();
    }

    // ---------- tickets ----------
    // Keep schema; open to any authenticated user
    match /tickets/{ticketId} {
      function allowedKeys() {
        return [
          'pickupTime','passengercount','ticketId','passenger','pickup','dropoff','notes',
          'scannedOutbound','scannedReturn','createdAt',
          'scannedOutboundAt','scannedOutboundBy','scannedReturnAt','scannedReturnBy'
        ];
      }

      function validators() {
        return {
          pickupTime:        (v) => v is timestamp,
          passengercount:    (v) => v is number,
          ticketId:          (v) => (v is string) || (v == null),
          passenger:         (v) => (v is string) || (v == null),
          pickup:            (v) => (v is string) || (v == null),
          dropoff:           (v) => (v is string) || (v == null),
          notes:             (v) => (v is string) || (v == null),
          scannedOutbound:   (v) => v is bool,
          scannedReturn:     (v) => v is bool,
          createdAt:         (v) => v is timestamp,
          scannedOutboundAt: (v) => (v is timestamp) || (v == null),
          scannedOutboundBy: (v) => (v is string) || (v == null),
          scannedReturnAt:   (v) => (v is timestamp) || (v == null),
          scannedReturnBy:   (v) => (v is string) || (v == null),
        };
      }

      allow read: if authed();

      // Full doc create
      allow create: if authed()
        && hasOnly(request.resource.data.keys(), allowedKeys())
        && validPartial(request.resource.data, validators())
        && request.resource.data.pickupTime is timestamp
        && request.resource.data.passengercount is number
        && request.resource.data.scannedOutbound is bool
        && request.resource.data.scannedReturn is bool
        && request.resource.data.createdAt is timestamp;

      // Partial update
      allow update: if authed()
        && hasOnly(request.resource.data.diff(resource.data).changedKeys(), allowedKeys())
        && validPartial(
          request.resource.data.diff(resource.data).affectedKeys()
            .reduce((m, k) => m.put(k, request.resource.data[k]), {}),
          validators()
        );

      allow delete: if authed();
    }

    // ---------- claimLog / claimFailures ----------
    match /claimLog/{id} {
      allow read: if authed();
      allow create, update: if authed()
        && request.resource.data.driver is string
        && request.resource.data.tripId is string
        && request.resource.data.timestamp is timestamp;
      allow delete: if authed();
    }

    match /claimFailures/{id} {
      allow read: if authed();
      allow create, update: if authed()
        && request.resource.data.tripId is string
        && request.resource.data.driverName is string
        && request.resource.data.attemptedAt is timestamp
        && request.resource.data.reason is string;
      allow delete: if authed();
    }

    // ---------- default deny ----------
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
