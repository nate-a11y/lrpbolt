<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no"
    />
    <title>LRP Hyperlane — Neon Runner</title>
    <style>
      :root { --lrp:#4cbb17; --bg:#060606; --fg:#e8f5e9; --panel:#0b0b0b; }
      * { box-sizing: border-box; }
      html, body { margin:0; height:100%; background:var(--bg); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
      #root { position:fixed; inset:0; display:grid; place-items:center; }
      .hud { position:absolute; top:10px; left:10px; right:10px; display:flex; justify-content:space-between; font-weight:800; letter-spacing:.3px; }
      .title { position:absolute; top:10px; left:50%; transform:translateX(-50%); color:var(--lrp); font-weight:900; text-transform:uppercase; letter-spacing:1px; }
      canvas { width:min(96vw,720px); height:min(72vh,540px); border-radius:16px; background:linear-gradient(180deg,#0a0a0a,#050505); box-shadow: 0 10px 30px rgba(0,0,0,.55), inset 0 0 0 1px rgba(255,255,255,.05); }
      .controls { position:absolute; bottom:14px; left:50%; transform:translateX(-50%); display:flex; gap:12px; }
      .btn { background:var(--lrp); color:#000; border:0; border-radius:12px; padding:12px 16px; font-weight:900; box-shadow:0 8px 24px rgba(76,187,23,.35); }
      .toast { position:absolute; top:44px; left:50%; transform:translateX(-50%); background:rgba(25,25,25,.92); border:1px solid rgba(255,255,255,.06); padding:6px 10px; border-radius:8px; font-size:12px; opacity:.92; }
    </style>
  </head>
  <body>
    <div id="root">
      <div class="hud">
        <div>Score: <span id="score">0</span></div>
        <div>Best: <span id="best">0</span></div>
      </div>
      <div class="title">LRP Hyperlane</div>
      <div class="toast">← / → to switch lanes • Tap left/right below on mobile</div>
      <canvas id="game" width="720" height="540" aria-label="Hyperlane game canvas"></canvas>
      <div class="controls">
        <button class="btn" id="left" aria-label="Move left">◀︎ Left</button>
        <button class="btn" id="restart" aria-label="Restart">Restart</button>
        <button class="btn" id="right" aria-label="Move right">Right ▶︎</button>
      </div>
    </div>
    <script>
      (function(){
        const W=720,H=540, LANES=3;
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const bestEl = document.getElementById('best');
        const btnL = document.getElementById('left');
        const btnR = document.getElementById('right');
        const btnRestart = document.getElementById('restart');

        const laneX = (lane)=> W*(0.2 + lane*0.3); // 0,1,2 lanes visually centered
        let best = Number(localStorage.getItem('lrp_hyperlane_best')||0);
        if (!Number.isFinite(best) || best < 0) best = 0;
        best = Math.floor(best);
        bestEl.textContent = String(best);

        const player = {
          lane: 1, x: laneX(1), y: H*0.76, targetX: laneX(1), speed: 5.2
        };

        const sound = (function(){
          const state = { enabled: false, ctx: null };
          const whenReadyQueue = [];

          function ensureContext(){
            if (state.ctx) return state.ctx;
            try {
              const AudioCtx = window.AudioContext || window.webkitAudioContext;
              if (!AudioCtx) return null;
              state.ctx = new AudioCtx();
              if (state.ctx.state === 'suspended' && state.enabled) {
                state.ctx.resume().catch(()=>{});
              }
              while (whenReadyQueue.length) {
                const job = whenReadyQueue.shift();
                if (job) job();
              }
              return state.ctx;
            } catch (err) {
              console.warn('[Hyperlane] audio init failed', err); // eslint-disable-line no-console
              return null;
            }
          }

          function playCoin(){
            const ctx = ensureContext();
            if (!ctx) return;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(880, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1760, ctx.currentTime + 0.15);
            gain.gain.setValueAtTime(0.001, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.15, ctx.currentTime + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);
            osc.connect(gain).connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.25);
          }

          function playBump(){
            const ctx = ensureContext();
            if (!ctx) return;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(220, ctx.currentTime);
            osc.frequency.linearRampToValueAtTime(110, ctx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.18, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.25);
            osc.connect(gain).connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.3);
          }

          function play(type){
            if (!state.enabled) return;
            const job = type === 'coin' ? playCoin : playBump;
            const ctx = ensureContext();
            if (!ctx) {
              whenReadyQueue.push(job);
              return;
            }
            if (ctx.state === 'suspended') {
              ctx.resume().then(job).catch(()=>{});
            } else {
              job();
            }
          }

          function setEnabled(value){
            state.enabled = Boolean(value);
            const ctx = state.ctx;
            if (!ctx) return;
            if (state.enabled && ctx.state === 'suspended') {
              ctx.resume().catch(()=>{});
            }
            if (!state.enabled && ctx.state === 'running') {
              ctx.suspend().catch(()=>{});
            }
          }

          function prime(){
            ensureContext();
            if (state.ctx && state.ctx.state === 'suspended' && state.enabled) {
              state.ctx.resume().catch(()=>{});
            }
          }

          window.addEventListener('pointerdown', prime, { once: true });
          window.addEventListener('keydown', prime, { once: true });

          return {
            playCoin(){ play('coin'); },
            playBump(){ play('bump'); },
            setEnabled,
          };
        })();

        function postSound(name){
          try {
            if (window && window.parent) {
              window.parent.postMessage({ type: 'SOUND', name }, '*');
            }
          } catch (err) {
            console.warn('[Hyperlane] sound post failed', err); // eslint-disable-line no-console
          }
        }

        let rings=[], blocks=[], t=0, running=false, score=0, speed=3, z=0;
        let lastFrameTime = null;

        function reset(){
          rings=[]; blocks=[]; t=0; score=0; speed=3; z=0;
          player.lane=1; player.x=laneX(1); player.targetX=laneX(1);
          scoreEl.textContent = '0';
          lastFrameTime = null;
          flashTick = 0;
          running=true;
        }

        function spawn(){
          // alternate pickups (rings) and obstacles (blocks)
          if (Math.random()<0.6){
            rings.push({ lane: Math.floor(Math.random()*LANES), y:-40, taken:false });
          } else {
            // ensure not impossible patterns
            const n = 1 + (Math.random()<0.3 ? 1:0);
            let used=new Set();
            for(let i=0;i<n;i++){
              let l;
              do{ l=Math.floor(Math.random()*LANES);} while(used.has(l));
              used.add(l);
              blocks.push({ lane:l, y:-40 });
            }
          }
        }

        function update(deltaSeconds){
          if (!running) return;
          const clampedDelta = Math.min(Math.max(deltaSeconds, 0), 0.2);
          if (clampedDelta <= 0) return;
          const frameScale = clampedDelta * 60;

          t += clampedDelta;
          while (t > 0.5){ t -= 0.5; spawn(); }
          z += speed * frameScale;

          // difficulty curve
          speed = Math.min(15, 3 + Math.log2(2+score/250));

          // player smooth lane move
          const smoothing = 1 - Math.pow(1 - 0.22, frameScale);
          player.x += (player.targetX - player.x) * smoothing;

          // move entities
          const dy = speed * 2.2 * frameScale;
          rings.forEach(r => r.y += dy);
          blocks.forEach(b => b.y += dy);

          // collect rings
          rings.forEach(r=>{
            if (!r.taken && r.lane===player.lane && Math.abs((H*0.76) - r.y) < 26){
              r.taken=true; score+=100; flash(); sound.playCoin();
              postSound('ring');
            }
          });

          // collide blocks
          for (const b of blocks){
            if (b.lane===player.lane && Math.abs((H*0.76) - b.y) < 28){
              gameOver(); return;
            }
          }

          // cleanup offscreen
          rings = rings.filter(r => r.y < H+60 && !r.taken);
          blocks = blocks.filter(b => b.y < H+60);

          // passive score
          score += Math.max(1, Math.floor(speed)) * frameScale;
          scoreEl.textContent = String(Math.floor(score));

          if (flashTick>0) { flashTick = Math.max(0, flashTick - frameScale); }
        }

        function drawGrid(){
          // neon hyperlane grid
          ctx.save();
          ctx.translate(0, (z%40));
          ctx.strokeStyle = 'rgba(255,255,255,0.06)';
          for (let y=-40; y<H; y+=40){
            ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
          }
          ctx.restore();

          // lane separators
          ctx.strokeStyle = 'rgba(255,255,255,0.10)';
          ctx.lineWidth = 2;
          for (let i=1;i<LANES;i++){
            const x = (laneX(i-1)+laneX(i))/2;
            ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.setLineDash([8,10]); ctx.stroke(); ctx.setLineDash([]);
          }
        }

        let flashTick = 0;
        function flash(){ flashTick = 8; }

        function draw(){
          ctx.clearRect(0,0,W,H);
          // bg
          const g=ctx.createLinearGradient(0,0,0,H);
          g.addColorStop(0,'#0b0b0b'); g.addColorStop(1,'#050505');
          ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

          drawGrid();

          // rings
          rings.forEach(r=>{
            const x=laneX(r.lane);
            ctx.beginPath(); ctx.arc(x, r.y, 10, 0, Math.PI*2);
            ctx.strokeStyle='rgba(76,187,23,0.9)'; ctx.lineWidth=3; ctx.stroke();
            ctx.beginPath(); ctx.arc(x, r.y, 3, 0, Math.PI*2);
            ctx.fillStyle='rgba(76,187,23,0.6)'; ctx.fill();
          });

          // blocks
          blocks.forEach(b=>{
            const x=laneX(b.lane);
            ctx.fillStyle='rgba(255,82,82,0.9)';
            roundRect(ctx, x-16, b.y-16, 32, 32, 6, true);
            ctx.fillStyle='rgba(0,0,0,0.25)';
            roundRect(ctx, x-16, b.y, 32, 10, 4, true);
          });

          // player craft
          ctx.save(); ctx.translate(player.x, H*0.76);
          const wobble = Math.sin(performance.now()/120)*2;
          ctx.rotate(wobble*Math.PI/180);
          ctx.fillStyle= flashTick>0 ? '#7dfd3e' : '#4cbb17';
          roundRect(ctx, -18, -22, 36, 44, 8, true, '#000');
          // cockpit
          ctx.fillStyle='#0b0b0b'; roundRect(ctx, -12, -8, 24, 20, 6, true);
          // thruster glow
          const glow=ctx.createRadialGradient(0,26,2,0,26,18);
          glow.addColorStop(0,'rgba(76,187,23,0.8)');
          glow.addColorStop(1,'rgba(76,187,23,0)');
          ctx.fillStyle=glow; ctx.beginPath(); ctx.arc(0,26,18,0,Math.PI*2); ctx.fill();
          ctx.restore();

        }

        function roundRect(ctx, x,y,w,h,r, fill=true){
          const rr = Math.min(r, w/2, h/2);
          ctx.beginPath();
          ctx.moveTo(x+rr,y);
          ctx.arcTo(x+w,y,x+w,y+h,rr);
          ctx.arcTo(x+w,y+h,x,y+h,rr);
          ctx.arcTo(x,y+h,x,y,rr);
          ctx.arcTo(x,y,x+w,y,rr);
          if (fill) ctx.fill(); else ctx.stroke();
        }

        function loop(now){
          if (!running) return;
          if (lastFrameTime === null) lastFrameTime = now;
          const deltaSeconds = (now - lastFrameTime) / 1000;
          lastFrameTime = now;
          update(deltaSeconds); draw();
          if (running) requestAnimationFrame(loop);
        }

        const portalOrigin = (() => {
          const fallback = 'https://lakeridepros.xyz';
          try {
            const ref = typeof document !== 'undefined' ? document.referrer : '';
            if (ref) {
              const url = new URL(ref);
              return url.origin || fallback;
            }
          } catch (error) {
            console.warn('[Hyperlane] could not resolve portal origin', error);
          }
          return fallback;
        })();

        function lrpPostScore(score){
          try {
            const numeric = Number(score);
            if (!Number.isFinite(numeric) || numeric < 0) return;
            if (typeof window === 'undefined' || !window.parent) return;
            window.parent.postMessage(
              { type: 'lrp:game-highscore', payload: { game: 'hyperlane', score: numeric } },
              portalOrigin,
            );
          } catch (error) {
            console.warn('[Hyperlane] postMessage failed', error);
          }
        }

        function gameOver(){
          running=false;
          sound.playBump();
          postSound('crash');
          const finalScore = Math.floor(score);
          scoreEl.textContent = String(finalScore);
          if (finalScore>best){ best=finalScore; localStorage.setItem('lrp_hyperlane_best', String(best)); bestEl.textContent=String(best); }
          lrpPostScore(finalScore);
        }

        function goLeft(){ if (!running) return; player.lane=Math.max(0, player.lane-1); player.targetX = laneX(player.lane); }
        function goRight(){ if (!running) return; player.lane=Math.min(LANES-1, player.lane+1); player.targetX = laneX(player.lane); }

        // input
        window.addEventListener('keydown', (e)=>{
          if (e.key==='ArrowLeft' || e.key==='a'){ goLeft(); }
          if (e.key==='ArrowRight' || e.key==='d'){ goRight(); }
          if (e.key===' ' && !running){ postSound('start'); start(); }
        });
        btnL.addEventListener('pointerdown', goLeft);
        btnR.addEventListener('pointerdown', goRight);
        btnRestart.addEventListener('click', ()=>{ postSound('start'); start(); });

        window.addEventListener('message', (event)=>{
          const payload = event?.data;
          if (!payload || typeof payload !== 'object') return;
          if (payload.type === 'HYPERLANE_SOUND_TOGGLE') {
            sound.setEnabled(Boolean(payload.enabled));
          }
        });

        function start(){
          running=false;
          reset();
          requestAnimationFrame(loop);
        }
        start();
      })();
    </script>
  </body>
</html>
