<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no"
    />
    <title>LRP Lake Crossing</title>
    <style>
      :root { --lrp:#4cbb17; --bg:#060606; --fg:#e8f5e9; --panel:#0b0b0b; }
      * { box-sizing: border-box; }
      html, body { margin:0; height:100%; background:var(--bg); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
      #root { position:fixed; inset:0; display:grid; place-items:center; padding:80px 10px 120px; }
      .hud { position:absolute; top:10px; left:10px; right:10px; display:flex; justify-content:space-between; font-weight:800; letter-spacing:.3px; font-size:14px; z-index:10; pointer-events:none; }
      .title { position:absolute; top:10px; left:50%; transform:translateX(-50%); color:var(--lrp); font-weight:900; text-transform:uppercase; letter-spacing:1px; font-size:16px; z-index:10; pointer-events:none; }
      canvas { width:min(96vw,720px); height:min(calc(100vh - 200px),540px); max-height:540px; border-radius:16px; background:linear-gradient(180deg,#0a0a0a,#050505); box-shadow: 0 10px 30px rgba(0,0,0,.55), inset 0 0 0 1px rgba(255,255,255,.05); }
      .controls { position:absolute; bottom:20px; left:50%; transform:translateX(-50%); display:flex; gap:12px; flex-wrap:wrap; justify-content:center; z-index:10; max-width:calc(100vw - 20px); }
      .btn { background:var(--lrp); color:#000; border:0; border-radius:12px; padding:12px 16px; font-weight:900; box-shadow:0 8px 24px rgba(76,187,23,.35); font-size:14px; cursor:pointer; }
      .btn:active { transform:translateY(2px); }
      .toast { position:absolute; top:44px; left:50%; transform:translateX(-50%); background:rgba(25,25,25,.92); border:1px solid rgba(255,255,255,.06); padding:6px 10px; border-radius:8px; font-size:12px; opacity:.92; z-index:10; pointer-events:none; max-width:calc(100vw - 20px); text-align:center; }
      @media (max-width: 640px) {
        #root { padding:70px 8px 140px; }
        .hud { font-size:12px; top:8px; left:8px; right:8px; }
        .title { font-size:14px; top:8px; }
        .toast { font-size:11px; top:40px; }
        .btn { padding:10px 14px; font-size:12px; }
        .controls { bottom:16px; gap:8px; }
        canvas { height:min(calc(100vh - 210px),540px); }
      }
    </style>
  </head>
  <body>
    <div id="root">
      <div class="hud">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
        <div>Best: <span id="best">0</span></div>
      </div>
      <div class="title">LRP Lake Crossing</div>
      <div class="toast">Arrow keys or tap buttons • Reach the marina spots!</div>
      <canvas id="game" width="720" height="540" aria-label="Lake Crossing game canvas"></canvas>
      <div class="controls">
        <button class="btn" id="up" aria-label="Move up">▲ Up</button>
        <button class="btn" id="left" aria-label="Move left">◀︎ Left</button>
        <button class="btn" id="restart" aria-label="Restart">Restart</button>
        <button class="btn" id="right" aria-label="Move right">Right ▶︎</button>
        <button class="btn" id="down" aria-label="Move down">▼ Down</button>
      </div>
    </div>
    <script>
      (function(){
        const W=720, H=540, GRID=36;
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const bestEl = document.getElementById('best');
        const btnUp = document.getElementById('up');
        const btnDown = document.getElementById('down');
        const btnLeft = document.getElementById('left');
        const btnRight = document.getElementById('right');
        const btnRestart = document.getElementById('restart');

        let best = Number(localStorage.getItem('lrp_lakecrossing_best')||0);
        if (!Number.isFinite(best) || best < 0) best = 0;
        best = Math.floor(best);
        bestEl.textContent = String(best);

        const sound = (function(){
          const state = { enabled: false, ctx: null };
          const whenReadyQueue = [];

          function ensureContext(){
            if (state.ctx) return state.ctx;
            try {
              const AudioCtx = window.AudioContext || window.webkitAudioContext;
              if (!AudioCtx) return null;
              state.ctx = new AudioCtx();
              if (state.ctx.state === 'suspended' && state.enabled) {
                state.ctx.resume().catch(()=>{});
              }
              while (whenReadyQueue.length) {
                const job = whenReadyQueue.shift();
                if (job) job();
              }
              return state.ctx;
            } catch (err) {
              console.warn('[LakeCrossing] audio init failed', err);
              return null;
            }
          }

          function playHop(){
            const ctx = ensureContext();
            if (!ctx) return;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(300, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.08);
            gain.gain.setValueAtTime(0.12, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.12);
            osc.connect(gain).connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.15);
          }

          function playScore(){
            const ctx = ensureContext();
            if (!ctx) return;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(523, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(784, ctx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.001, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.18, ctx.currentTime + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.25);
            osc.connect(gain).connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.3);
          }

          function playCrash(){
            const ctx = ensureContext();
            if (!ctx) return;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, ctx.currentTime);
            osc.frequency.linearRampToValueAtTime(50, ctx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.2, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.35);
            osc.connect(gain).connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.4);
          }

          function play(type){
            if (!state.enabled) return;
            const job = type === 'hop' ? playHop : type === 'score' ? playScore : playCrash;
            const ctx = ensureContext();
            if (!ctx) {
              whenReadyQueue.push(job);
              return;
            }
            if (ctx.state === 'suspended') {
              ctx.resume().then(job).catch(()=>{});
            } else {
              job();
            }
          }

          function setEnabled(value){
            state.enabled = Boolean(value);
            const ctx = state.ctx;
            if (!ctx) return;
            if (state.enabled && ctx.state === 'suspended') {
              ctx.resume().catch(()=>{});
            }
            if (!state.enabled && ctx.state === 'running') {
              ctx.suspend().catch(()=>{});
            }
          }

          function prime(){
            ensureContext();
            if (state.ctx && state.ctx.state === 'suspended' && state.enabled) {
              state.ctx.resume().catch(()=>{});
            }
          }

          window.addEventListener('pointerdown', prime, { once: true });
          window.addEventListener('keydown', prime, { once: true });

          return {
            playHop(){ play('hop'); },
            playScore(){ play('score'); },
            playCrash(){ play('crash'); },
            setEnabled,
          };
        })();

        function postSound(name){
          try {
            if (window && window.parent) {
              window.parent.postMessage({ type: 'SOUND', name }, '*');
            }
          } catch (err) {
            console.warn('[LakeCrossing] sound post failed', err);
          }
        }

        // Game state
        let player = { x: 10, y: 14, moving: false, targetX: 10, targetY: 14 };
        let lanes = [];
        let goals = [false, false, false, false, false];
        let lives = 3;
        let score = 0;
        let level = 1;
        let running = false;
        let respawnTimer = 0;
        let flashTick = 0;

        function reset(){
          player = { x: 10, y: 14, moving: false, targetX: 10, targetY: 14 };
          goals = [false, false, false, false, false];
          lives = 3;
          score = 0;
          level = 1;
          respawnTimer = 0;
          flashTick = 0;
          scoreEl.textContent = '0';
          livesEl.textContent = '3';
          initLanes();
          running = true;
        }

        function initLanes(){
          lanes = [
            { row: 0, type: 'goal', speed: 0, items: [] }, // goal row
            { row: 1, type: 'safe', speed: 0, items: [] }, // safe zone
            { row: 2, type: 'water', speed: 2.5, items: [], dir: 1 }, // boat
            { row: 3, type: 'water', speed: 1.8, items: [], dir: -1 }, // jet ski
            { row: 4, type: 'water', speed: 3.2, items: [], dir: 1 }, // boat fast
            { row: 5, type: 'water', speed: 2.0, items: [], dir: -1 }, // boat
            { row: 6, type: 'safe', speed: 0, items: [] }, // dock
            { row: 7, type: 'road', speed: 2.2, items: [], dir: 1 }, // car
            { row: 8, type: 'road', speed: 1.5, items: [], dir: -1 }, // car slow
            { row: 9, type: 'road', speed: 2.8, items: [], dir: 1 }, // car fast
            { row: 10, type: 'road', speed: 1.9, items: [], dir: -1 }, // car
            { row: 11, type: 'road', speed: 3.5, items: [], dir: 1 }, // car very fast
            { row: 12, type: 'safe', speed: 0, items: [] }, // sidewalk
            { row: 13, type: 'road', speed: 2.0, items: [], dir: -1 }, // car
            { row: 14, type: 'start', speed: 0, items: [] }, // start
          ];

          // Spawn initial obstacles
          lanes.forEach((lane, idx) => {
            if (lane.type === 'road' || lane.type === 'water') {
              const count = 2 + Math.floor(Math.random() * 2);
              for (let i = 0; i < count; i++) {
                lane.items.push({
                  x: (W / count) * i + Math.random() * 80,
                  width: lane.type === 'road' ? 48 : 64,
                });
              }
            }
          });
        }

        function move(dx, dy){
          if (!running || respawnTimer > 0 || player.moving) return;
          const newX = player.x + dx;
          const newY = player.y + dy;

          if (newX < 0 || newX >= 20 || newY < 0 || newY >= 15) return;

          player.targetX = newX;
          player.targetY = newY;
          player.moving = true;
          sound.playHop();
          postSound('hop');

          // Award points for forward progress
          if (dy < 0 && player.y > 0) {
            score += 10;
            scoreEl.textContent = String(Math.floor(score));
          }
        }

        function checkCollision(){
          const lane = lanes[player.y];
          if (!lane) return false;

          if (lane.type === 'road' || lane.type === 'water') {
            const px = player.x * GRID + GRID/2;
            for (const item of lane.items) {
              const left = item.x;
              const right = item.x + item.width;
              if (px > left - GRID/2 && px < right + GRID/2) {
                return true;
              }
            }
          }

          return false;
        }

        function checkGoal(){
          if (player.y !== 0) return;

          const goalSlots = [2, 6, 10, 14, 18]; // x positions for goal spots
          for (let i = 0; i < goalSlots.length; i++) {
            if (Math.abs(player.x - goalSlots[i]) <= 1 && !goals[i]) {
              goals[i] = true;
              score += 200;
              sound.playScore();
              postSound('goal');
              scoreEl.textContent = String(Math.floor(score));
              flashTick = 10;

              // Reset player to start
              player.x = 10;
              player.y = 14;
              player.targetX = 10;
              player.targetY = 14;

              // Check if all goals reached
              if (goals.every(g => g)) {
                levelUp();
              }
              return true;
            }
          }
          return false;
        }

        function levelUp(){
          level++;
          score += 500;
          scoreEl.textContent = String(Math.floor(score));
          goals = [false, false, false, false, false];

          // Increase difficulty
          lanes.forEach(lane => {
            if (lane.type === 'road' || lane.type === 'water') {
              lane.speed *= 1.15;
            }
          });
        }

        function die(){
          lives--;
          livesEl.textContent = String(lives);
          sound.playCrash();
          postSound('crash');

          if (lives <= 0) {
            gameOver();
          } else {
            respawnTimer = 60;
            player.x = 10;
            player.y = 14;
            player.targetX = 10;
            player.targetY = 14;
          }
        }

        function update(){
          if (!running) return;

          if (respawnTimer > 0) {
            respawnTimer--;
            return;
          }

          // Update player movement
          if (player.moving) {
            const dx = player.targetX - player.x;
            const dy = player.targetY - player.y;
            if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) {
              player.x = player.targetX;
              player.y = player.targetY;
              player.moving = false;

              if (!checkGoal() && checkCollision()) {
                die();
              }
            } else {
              player.x += dx * 0.25;
              player.y += dy * 0.25;
            }
          } else {
            // Check collision even when not moving (for water/road lanes)
            if (checkCollision()) {
              die();
            }
          }

          // Update obstacles
          lanes.forEach(lane => {
            if (lane.type === 'road' || lane.type === 'water') {
              lane.items.forEach(item => {
                item.x += lane.speed * lane.dir;

                // Wrap around
                if (lane.dir > 0 && item.x > W + 100) {
                  item.x = -item.width - 100;
                }
                if (lane.dir < 0 && item.x < -item.width - 100) {
                  item.x = W + 100;
                }
              });
            }
          });

          if (flashTick > 0) flashTick--;
        }

        function draw(){
          ctx.clearRect(0, 0, W, H);

          // Background gradient
          const g = ctx.createLinearGradient(0, 0, 0, H);
          g.addColorStop(0, '#0b0b0b');
          g.addColorStop(1, '#050505');
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, W, H);

          // Draw lanes
          lanes.forEach((lane, idx) => {
            const y = idx * GRID;

            if (lane.type === 'goal') {
              ctx.fillStyle = 'rgba(76, 187, 23, 0.15)';
              ctx.fillRect(0, y, W, GRID);
            } else if (lane.type === 'safe' || lane.type === 'start') {
              ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
              ctx.fillRect(0, y, W, GRID);
            } else if (lane.type === 'road') {
              ctx.fillStyle = 'rgba(60, 60, 60, 0.6)';
              ctx.fillRect(0, y, W, GRID);
              // Lane lines
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
              ctx.setLineDash([10, 8]);
              ctx.beginPath();
              ctx.moveTo(0, y + GRID/2);
              ctx.lineTo(W, y + GRID/2);
              ctx.stroke();
              ctx.setLineDash([]);
            } else if (lane.type === 'water') {
              ctx.fillStyle = 'rgba(30, 144, 255, 0.2)';
              ctx.fillRect(0, y, W, GRID);
            }
          });

          // Draw goal spots
          const goalSlots = [2, 6, 10, 14, 18];
          goalSlots.forEach((gx, i) => {
            const x = gx * GRID;
            if (goals[i]) {
              ctx.fillStyle = '#4cbb17';
              roundRect(ctx, x, 4, GRID - 8, GRID - 8, 6, true);
              ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
              ctx.font = 'bold 18px sans-serif';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText('✓', x + GRID/2, GRID/2);
            } else {
              ctx.strokeStyle = 'rgba(76, 187, 23, 0.5)';
              ctx.lineWidth = 2;
              roundRect(ctx, x + 4, 8, GRID - 16, GRID - 16, 4, false);
            }
          });

          // Draw obstacles
          lanes.forEach((lane, idx) => {
            const y = idx * GRID;
            if (lane.type === 'road') {
              lane.items.forEach(item => {
                ctx.fillStyle = '#FF5252';
                roundRect(ctx, item.x, y + 4, item.width, GRID - 8, 4, true);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(item.x + 6, y + 12, item.width - 12, 8);
              });
            } else if (lane.type === 'water') {
              lane.items.forEach(item => {
                ctx.fillStyle = '#29B6F6';
                roundRect(ctx, item.x, y + 6, item.width, GRID - 12, 6, true);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(item.x + 8, y + 12, item.width - 16, 6);
              });
            }
          });

          // Draw player
          if (respawnTimer === 0) {
            ctx.save();
            ctx.translate(player.x * GRID + GRID/2, player.y * GRID + GRID/2);
            ctx.fillStyle = flashTick > 0 ? '#7dfd3e' : '#4cbb17';
            roundRect(ctx, -12, -14, 24, 28, 6, true);
            ctx.fillStyle = '#0b0b0b';
            roundRect(ctx, -8, -6, 16, 12, 4, true);
            ctx.restore();
          } else {
            // Respawn flicker
            if (Math.floor(respawnTimer / 5) % 2 === 0) {
              ctx.save();
              ctx.globalAlpha = 0.5;
              ctx.translate(10 * GRID + GRID/2, 14 * GRID + GRID/2);
              ctx.fillStyle = '#4cbb17';
              roundRect(ctx, -12, -14, 24, 28, 6, true);
              ctx.restore();
            }
          }
        }

        function roundRect(ctx, x, y, w, h, r, fill = true) {
          const rr = Math.min(r, w/2, h/2);
          ctx.beginPath();
          ctx.moveTo(x + rr, y);
          ctx.arcTo(x + w, y, x + w, y + h, rr);
          ctx.arcTo(x + w, y + h, x, y + h, rr);
          ctx.arcTo(x, y + h, x, y, rr);
          ctx.arcTo(x, y, x + w, y, rr);
          if (fill) ctx.fill(); else ctx.stroke();
        }

        function loop(){
          if (!running) return;
          update();
          draw();
          requestAnimationFrame(loop);
        }

        const portalOrigin = (() => {
          const fallback = 'https://lakeridepros.xyz';
          try {
            const ref = typeof document !== 'undefined' ? document.referrer : '';
            if (ref) {
              const url = new URL(ref);
              return url.origin || fallback;
            }
          } catch (error) {
            console.warn('[LakeCrossing] could not resolve portal origin', error);
          }
          return fallback;
        })();

        function lrpPostScore(score){
          try {
            const numeric = Number(score);
            if (!Number.isFinite(numeric) || numeric < 0) return;
            if (typeof window === 'undefined' || !window.parent) return;
            window.parent.postMessage(
              { type: 'lrp:game-highscore', payload: { game: 'lakecrossing', score: numeric } },
              portalOrigin,
            );
          } catch (error) {
            console.warn('[LakeCrossing] postMessage failed', error);
          }
        }

        function gameOver(){
          running = false;
          const finalScore = Math.floor(score);
          scoreEl.textContent = String(finalScore);
          if (finalScore > best) {
            best = finalScore;
            localStorage.setItem('lrp_lakecrossing_best', String(best));
            bestEl.textContent = String(best);
          }
          lrpPostScore(finalScore);
        }

        // Input handlers
        function goUp(){ move(0, -1); }
        function goDown(){ move(0, 1); }
        function goLeft(){ move(-1, 0); }
        function goRight(){ move(1, 0); }

        window.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowUp' || e.key === 'w') { e.preventDefault(); goUp(); }
          if (e.key === 'ArrowDown' || e.key === 's') { e.preventDefault(); goDown(); }
          if (e.key === 'ArrowLeft' || e.key === 'a') { e.preventDefault(); goLeft(); }
          if (e.key === 'ArrowRight' || e.key === 'd') { e.preventDefault(); goRight(); }
          if (e.key === ' ' && !running) { postSound('start'); start(); }
        });

        btnUp.addEventListener('pointerdown', goUp);
        btnDown.addEventListener('pointerdown', goDown);
        btnLeft.addEventListener('pointerdown', goLeft);
        btnRight.addEventListener('pointerdown', goRight);
        btnRestart.addEventListener('click', () => { postSound('start'); start(); });

        window.addEventListener('message', (event) => {
          const payload = event?.data;
          if (!payload || typeof payload !== 'object') return;
          if (payload.type === 'LAKECROSSING_SOUND_TOGGLE') {
            sound.setEnabled(Boolean(payload.enabled));
          }
        });

        function start(){
          running = false;
          reset();
          requestAnimationFrame(loop);
        }

        start();
      })();
    </script>
  </body>
</html>
